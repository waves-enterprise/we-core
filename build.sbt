import com.typesafe.sbt.git.JGit
import com.wavesenterprise.grpc.GrpcApiVersionGenerator
import com.wavesenterprise.transaction.generator.{TxSchemePlugin, TxSchemeProtoPlugin, TxSchemeTypeScriptPlugin}
import sbt.Keys.{credentials, sourceGenerators, _}
import sbt.{Compile, Credentials, Def, Path, _}
import sbtcrossproject.CrossPlugin.autoImport.crossProject

import java.io.File
import scala.jdk.CollectionConverters._

enablePlugins(GitVersioning)
ThisBuild / scalafmtOnCompile := true

Global / cancelable := true
Global / onChangedBuildSource := ReloadOnSourceChanges

run / fork := true

name := "we-core"

inThisBuild(
  Seq(
    scalaVersion := "2.12.10",
    organization := "com.wavesenterprise",
    organizationName := "wavesenterprise",
    organizationHomepage := Some(url("https://wavesenterprise.com")),
    description := "Library for Waves Enterprise blockchain platform",
    homepage := Some(url("https://github.com/waves-enterprise/we-core")),
    pomIncludeRepository := { _ =>
      false
    },
    publishMavenStyle := true,
    licenses ++= Seq(
      "Apache-2.0" -> url("http://www.apache.org/licenses/LICENSE-2.0.txt")
    ),
    scmInfo := Some(
      ScmInfo(
        url("https://github.com/waves-enterprise/we-core"),
        "scm:git@github.com:waves-enterprise/we-core.git"
      )
    ),
    developers ++= List(
      Developer("wavesenterprise", "Waves Enterprise", "dev@wavesenterprise.com", url("https://wavesenterprise.com")),
      Developer("1estart", "Artemiy Pospelov", "artemiywaves@gmail.com", url("https://github.com/1estart")),
      Developer("deadblackclover", "Mark Ikonnikov", "deadblackclover@protonmail.com", url("https://github.com/deadblackclover")),
      Developer("np96", "Nikolai Poperechnyi", "npoperechnyi@web3tech.ru,n.poperechnyi@gmail.com", url("https://github.com/np96")),
      Developer("GiperMeon", "Evgeniy Gnatovskiy", "egnatovskiy@web3tech.ru,gnatoffskiy43@gmail.com", url("https://github.com/GiperMeon")),
      Developer("arlengur", "Alex Galin", "satovritti@gmail.com", url("https://github.com/arlengur")),
    ),
    crossPaths := false,
    scalacOptions ++= Seq(
      "-feature",
      "-deprecation",
      "-language:higherKinds",
      "-language:implicitConversions",
      "-Ywarn-unused:-implicits",
      "-Xlint",
      "-Ypartial-unification"
    )
  )
)

ThisBuild / versionScheme := Some("semver-spec")

/**
  * You have to put your credentials in a local file ~/.sbt/.credentials
  * File structure:
  *
  * realm=Sonatype Nexus Repository Manager
  * host=artifacts.wavesenterprise.com
  * username={YOUR_LDAP_USERNAME}
  * password={YOUR_LDAP_PASSWORD}
  */
credentials += {
  val envUsernameOpt = sys.env.get("nexusUser")
  val envPasswordOpt = sys.env.get("nexusPassword")

  (envUsernameOpt, envPasswordOpt) match {
    case (Some(username), Some(password)) =>
      println("Using credentials from environment for artifacts.wavesenterprise.com")
      Credentials("Sonatype Nexus Repository Manager", "artifacts.wavesenterprise.com", username, password)

    case _ if isSnapshotVersion.value =>
      val localCredentialsFile = Path.userHome / ".sbt" / ".credentials"
      println(s"Going to use ${localCredentialsFile.getAbsolutePath} as credentials for artifacts.wavesenterprise.com")
      Credentials(localCredentialsFile)

    case _ =>
      val localCredentialsFile = Path.userHome / ".sbt" / ".sonatype-credentials"
      println(s"Going to use ${localCredentialsFile.getAbsolutePath} as credentials for s01.oss.sonatype.org")
      Credentials(localCredentialsFile)
  }
}

val coreVersionSource = Def.task {
  // WARNING!!!
  // Please, update the fallback version every major and minor releases.
  // This version is used then building from sources without Git repository
  // In case of not updating the version cores build from headless sources will fail to connect to newer versions
  val FallbackVersion = (1, 0, 0)

  val coreVersionFile: File = (Compile / sourceManaged).value / "com" / "wavesenterprise" / "CoreVersion.scala"
  val versionExtractor      = """(\d+)\.(\d+)\.(\d+).*""".r
  val (major, minor, patch) = version.value match {
    case versionExtractor(ma, mi, pa) => (ma.toInt, mi.toInt, pa.toInt)
    case _                            => FallbackVersion
  }

  IO.write(
    coreVersionFile,
    s"""package com.wavesenterprise
       |
       |object CoreVersion {
       |  val VersionString = "${version.value}"
       |  val VersionTuple = ($major, $minor, $patch)
       |}
       |""".stripMargin
  )

  Seq(coreVersionFile)
}

normalizedName := s"${name.value}"

lazy val branchName = Def.setting[String](sys.env.getOrElse("CI_COMMIT_REF_NAME", git.gitCurrentBranch.value))

/**
  * The version is generated by the first possible method in the following order:
  *   Release version – {Tag}[-DIRTY]. When the tag corresponding to the version pattern is set on the last commit;
  *   Snapshot version – {Tag}-{Commits-ahead}-{Branch-name}-{Commit-hash}[-DIRTY]-SNAPSHOT. When the `git describe --tags` is worked;
  *   Fallback version – {Current-date}-SNAPSHOT.
  */
ThisBuild / version := {
  if (git.gitUncommittedChanges.value) {
    val changes = JGit(baseDirectory.value).porcelain
      .status()
      .call()
      .getUncommittedChanges
      .asScala
      .mkString("\n")

    println(s"Uncommitted changes detected:\n$changes")
  }

  val uncommittedChangesSuffix = git.makeUncommittedSignifierSuffix(git.gitUncommittedChanges.value, Some("DIRTY"))
  val snapshotSuffix           = "SNAPSHOT"

  val releaseVersion = git.releaseVersion(git.gitCurrentTags.value, git.gitTagToVersionNumber.value, uncommittedChangesSuffix)

  lazy val snapshotVersion = git.gitDescribedVersion.value.map { described =>
    val commitHashLength                          = 7
    val (tagVersionWithoutCommitHash, commitHash) = described.splitAt(described.length - commitHashLength)
    val tagVersionWithCommitsAhead                = tagVersionWithoutCommitHash.dropRight(2)
    val branchSuffix                              = branchName.value.replaceAll("/", "__")
    s"$tagVersionWithCommitsAhead-$branchSuffix-$commitHash$uncommittedChangesSuffix-$snapshotSuffix"
  }

  lazy val fallbackVersion = s"${git.formattedDateVersion.value}-$snapshotSuffix"

  (releaseVersion orElse snapshotVersion) getOrElse fallbackVersion
}

scalacOptions ++= Seq(
  "-feature",
  "-deprecation",
  "-language:higherKinds",
  "-language:implicitConversions",
  "-Ywarn-unused:-implicits",
  "-Xlint",
  "-Yresolve-term-conflict:object",
  "-Ypartial-unification",
  "-language:postfixOps"
)

inConfig(Compile)(
  Seq(
    packageDoc / publishArtifact := !isSnapshotVersion.value,
    packageSrc / publishArtifact := true,
    packageBin / publishArtifact := true,
    sourceGenerators += coreVersionSource
  ))

inConfig(Test)(
  Seq(
    logBuffered := false,
    fork := true,
    parallelExecution := true,
    testListeners := Seq.empty,
    javaOptions ++= Seq("-Dnode.crypto.type=WAVES"),
    testOptions += Tests.Argument("-oIDOF", "-u", "target/test-reports"),
    testOptions += Tests.Setup({ _ =>
      sys.props("sbt-testing") = "true"
    }),
    packageDoc / publishArtifact := false,
    packageSrc / publishArtifact := false,
    packageBin / publishArtifact := false
  ))

lazy val lang =
  crossProject(JSPlatform, JVMPlatform)
    .withoutSuffixFor(JVMPlatform)
    .settings(
      // the following line forces scala version across all dependencies
      scalaModuleInfo ~= (_.map(_.withOverrideScalaVersion(true))),
      addCompilerPlugin(Dependencies.kindProjector),
      libraryDependencies ++=
        Dependencies.catsCore ++
          Dependencies.fp ++
          Dependencies.scalacheck ++
          Dependencies.scorex ++
          Dependencies.scalatest ++
          Dependencies.monix.value ++
          Dependencies.scodec.value ++
          Dependencies.fastparse.value,
      resolvers += Resolver.bintrayIvyRepo("portable-scala", "sbt-plugins"),
      resolvers += Resolver.sbtPluginRepo("releases")
    )
    .jsSettings(
      scalaJSLinkerConfig ~= {
        _.withModuleKind(ModuleKind.CommonJSModule)
      }
    )
    .jvmSettings(
      name := "RIDE Compiler",
      normalizedName := "lang",
      description := "The RIDE smart contract language compiler",
      licenses := Seq(("MIT", url("https://github.com/wavesplatform/Waves/blob/master/LICENSE"))),
      libraryDependencies ++= Seq(
        "org.scala-js"                      %% "scalajs-stubs" % "1.0.0-RC1" % "provided",
        "com.github.spullara.mustache.java" % "compiler" % "0.9.5"
      ) ++ Dependencies.logging.map(_       % "test") // scrypto logs an error if a signature verification was failed
    )

lazy val langJS = lang.js
lazy val langJVM = lang.jvm
  .dependsOn(crypto)
  .aggregate(crypto)
  .settings(
    moduleName := "we-lang",
    publishTo := publishingRepo.value,
    Compile / packageDoc / publishArtifact := !isSnapshotVersion.value
  )

lazy val utils = project
  .settings(
    publishTo := publishingRepo.value,
    Compile / packageDoc / publishArtifact := !isSnapshotVersion.value
  )

lazy val models = project
  .enablePlugins(TxSchemePlugin)
  .dependsOn(langJVM, grpcProtobuf)
  .aggregate(langJVM, grpcProtobuf)
  .settings(
    publishTo := publishingRepo.value,
    Compile / packageDoc / publishArtifact := !isSnapshotVersion.value
  )

lazy val crypto = project
  .dependsOn(utils)
  .aggregate(utils)
  .settings(
    publishTo := publishingRepo.value,
    Compile / packageDoc / publishArtifact := !isSnapshotVersion.value
  )

lazy val testCore: Project = (project in file("test-core"))
  .dependsOn(models)
  .aggregate(models)
  .settings(
    moduleName := "we-test-core",
    libraryDependencies ++= Seq(Dependencies.commonsLang, Dependencies.netty).flatten,
    scalacOptions += "-Yresolve-term-conflict:object",
    publishTo := publishingRepo.value,
    Compile / packageDoc / publishArtifact := !isSnapshotVersion.value
  )

val grpcProtobufVersion = "1.10"

lazy val grpcProtobuf = (project in file("grpc-protobuf"))
  .enablePlugins(AkkaGrpcPlugin, GrpcApiVersionGenerator)
  .dependsOn(transactionProtobuf)
  .aggregate(transactionProtobuf)
  .settings(
    version := s"$grpcProtobufVersion-${version.value}",
    publishTo := publishingRepo.value,
    Compile / packageDoc / publishArtifact := !isSnapshotVersion.value
  )

lazy val transactionProtobuf = (project in file("transaction-protobuf"))
  .enablePlugins(TxSchemeProtoPlugin, AkkaGrpcPlugin)
  .settings(
    version := s"$grpcProtobufVersion-${version.value}",
    moduleName := "we-transaction-protobuf",
    scalacOptions += "-Yresolve-term-conflict:object",
    libraryDependencies ++= Dependencies.protobuf,
    publishTo := publishingRepo.value,
    Compile / packageDoc / publishArtifact := !isSnapshotVersion.value
  )

lazy val protobufZipTask = taskKey[File]("archive-protobuf")

lazy val protobufZipSetting: Def.Setting[Task[File]] = protobufZipTask := {
  (transactionProtobuf / Compile / compile).value
  (grpcProtobuf / Compile / compile).value

  val txProtoDir   = (transactionProtobuf / sourceDirectory).value / "main" / "protobuf"
  val grpcProtoDir = (grpcProtobuf / sourceDirectory).value / "main" / "protobuf"
  val zipName      = s"we_protobuf_${version.value}.zip"

  IO.delete((new sbt.File("./target/") * "we_protobuf_*.zip").get)

  val filesToZip = for {
    pathFinder    <- Set(txProtoDir, grpcProtoDir)
    directory     <- pathFinder.get()
    fileWithPaths <- Path.selectSubpaths(directory, "*.proto" | "*.md")
  } yield fileWithPaths

  val outputZip = new sbt.File("./target/", zipName)

  IO.zip(filesToZip, outputZip, None)
  println(s"Protobuf archive has been created: '${outputZip.getAbsolutePath}'")
  outputZip
}

lazy val transactionTypeScript = (project in file("transactions-factory"))
  .enablePlugins(TxSchemeTypeScriptPlugin)
  .settings(
    scalacOptions += "-Yresolve-term-conflict:object",
    publish / skip := true
  )

lazy val protobufArchives = (project in file("we-transaction-protobuf"))
  .dependsOn(grpcProtobuf)
  .settings(
    version := s"$grpcProtobufVersion-${version.value}",
    name := "we-protobuf-archive",
    publishTo := publishingRepo.value,
    Compile / packageSrc / publishArtifact := false,
    Compile / packageBin / publishArtifact := false,
    Compile / packageDoc / publishArtifact := !isSnapshotVersion.value,
    protobufZipSetting,
    Compile / protobufZipTask / artifact ~= ((art: Artifact) => art.withType("zip").withExtension("zip")),
    addArtifact(Compile / protobufZipTask / artifact, protobufZipTask)
  )

lazy val isSnapshotVersion: Def.Initialize[Boolean] = version(_ endsWith "-SNAPSHOT")

lazy val publishingRepo: Def.Initialize[Some[Resolver]] = isSnapshotVersion {
  case true =>
    Some("Sonatype Nexus Snapshots Repository Manager" at "https://artifacts.wavesenterprise.com/repository/we-snapshots")
  case _ =>
    Some("releases" at "https://s01.oss.sonatype.org/service/local/staging/deploy/maven2")
}

lazy val core = project
  .in(file("."))
  .dependsOn(models, testCore % "test->test")
  .aggregate(transactionTypeScript, testCore, protobufArchives)
  .settings(
    moduleName := "we-core",
    addCompilerPlugin(Dependencies.kindProjector),
    libraryDependencies ++= Seq(
      Dependencies.scalatest,
      Dependencies.scalacheck,
      Dependencies.commonsLang,
      Dependencies.docker,
      Dependencies.asyncHttpClient,
      Dependencies.netty
    ).flatten,
    publishTo := publishingRepo.value,
    cleanFiles += (transactionProtobuf / sourceDirectory).value / "main" / "protobuf" / "managed",
    cleanFiles += (grpcProtobuf / sourceDirectory).value / "main" / "protobuf" / "managed",
    cleanFiles ++= ((transactionTypeScript / baseDirectory).value * "we-transaction_typescript_*.zip").get,
    cleanFiles += (transactionTypeScript / baseDirectory).value / "node_modules"
  )
